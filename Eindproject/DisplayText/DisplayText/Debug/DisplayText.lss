
DisplayText.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000098  00800100  00000324  000003b8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000324  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000024  00800198  00800198  00000450  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000450  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000480  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000140  00000000  00000000  000004bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000014f7  00000000  00000000  000005fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000ce6  00000000  00000000  00001af3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000949  00000000  00000000  000027d9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000002a0  00000000  00000000  00003124  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000618  00000000  00000000  000033c4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000685  00000000  00000000  000039dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000100  00000000  00000000  00004061  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	45 c0       	rjmp	.+138    	; 0x8c <__ctors_end>
   2:	00 00       	nop
   4:	60 c0       	rjmp	.+192    	; 0xc6 <__bad_interrupt>
   6:	00 00       	nop
   8:	5e c0       	rjmp	.+188    	; 0xc6 <__bad_interrupt>
   a:	00 00       	nop
   c:	5c c0       	rjmp	.+184    	; 0xc6 <__bad_interrupt>
   e:	00 00       	nop
  10:	5a c0       	rjmp	.+180    	; 0xc6 <__bad_interrupt>
  12:	00 00       	nop
  14:	58 c0       	rjmp	.+176    	; 0xc6 <__bad_interrupt>
  16:	00 00       	nop
  18:	56 c0       	rjmp	.+172    	; 0xc6 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	54 c0       	rjmp	.+168    	; 0xc6 <__bad_interrupt>
  1e:	00 00       	nop
  20:	52 c0       	rjmp	.+164    	; 0xc6 <__bad_interrupt>
  22:	00 00       	nop
  24:	50 c0       	rjmp	.+160    	; 0xc6 <__bad_interrupt>
  26:	00 00       	nop
  28:	4e c0       	rjmp	.+156    	; 0xc6 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	4c c0       	rjmp	.+152    	; 0xc6 <__bad_interrupt>
  2e:	00 00       	nop
  30:	4a c0       	rjmp	.+148    	; 0xc6 <__bad_interrupt>
  32:	00 00       	nop
  34:	48 c0       	rjmp	.+144    	; 0xc6 <__bad_interrupt>
  36:	00 00       	nop
  38:	46 c0       	rjmp	.+140    	; 0xc6 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	44 c0       	rjmp	.+136    	; 0xc6 <__bad_interrupt>
  3e:	00 00       	nop
  40:	42 c0       	rjmp	.+132    	; 0xc6 <__bad_interrupt>
  42:	00 00       	nop
  44:	40 c0       	rjmp	.+128    	; 0xc6 <__bad_interrupt>
  46:	00 00       	nop
  48:	3e c0       	rjmp	.+124    	; 0xc6 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	3c c0       	rjmp	.+120    	; 0xc6 <__bad_interrupt>
  4e:	00 00       	nop
  50:	3a c0       	rjmp	.+116    	; 0xc6 <__bad_interrupt>
  52:	00 00       	nop
  54:	38 c0       	rjmp	.+112    	; 0xc6 <__bad_interrupt>
  56:	00 00       	nop
  58:	36 c0       	rjmp	.+108    	; 0xc6 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	34 c0       	rjmp	.+104    	; 0xc6 <__bad_interrupt>
  5e:	00 00       	nop
  60:	32 c0       	rjmp	.+100    	; 0xc6 <__bad_interrupt>
  62:	00 00       	nop
  64:	30 c0       	rjmp	.+96     	; 0xc6 <__bad_interrupt>
  66:	00 00       	nop
  68:	2e c0       	rjmp	.+92     	; 0xc6 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	2c c0       	rjmp	.+88     	; 0xc6 <__bad_interrupt>
  6e:	00 00       	nop
  70:	2a c0       	rjmp	.+84     	; 0xc6 <__bad_interrupt>
  72:	00 00       	nop
  74:	28 c0       	rjmp	.+80     	; 0xc6 <__bad_interrupt>
  76:	00 00       	nop
  78:	26 c0       	rjmp	.+76     	; 0xc6 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	24 c0       	rjmp	.+72     	; 0xc6 <__bad_interrupt>
  7e:	00 00       	nop
  80:	22 c0       	rjmp	.+68     	; 0xc6 <__bad_interrupt>
  82:	00 00       	nop
  84:	20 c0       	rjmp	.+64     	; 0xc6 <__bad_interrupt>
  86:	00 00       	nop
  88:	1e c0       	rjmp	.+60     	; 0xc6 <__bad_interrupt>
	...

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e4 e2       	ldi	r30, 0x24	; 36
  a0:	f3 e0       	ldi	r31, 0x03	; 3
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a8 39       	cpi	r26, 0x98	; 152
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	21 e0       	ldi	r18, 0x01	; 1
  b4:	a8 e9       	ldi	r26, 0x98	; 152
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	ac 3b       	cpi	r26, 0xBC	; 188
  be:	b2 07       	cpc	r27, r18
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	22 d1       	rcall	.+580    	; 0x308 <main>
  c4:	2d c1       	rjmp	.+602    	; 0x320 <_exit>

000000c6 <__bad_interrupt>:
  c6:	9c cf       	rjmp	.-200    	; 0x0 <__vectors>

000000c8 <upOffset>:
 void setLed(int row,int column,int status)
 {
	
	if((row >= 0 && row < 8) && (column >= 0 && column < 8))
	{
		board[row] = status;
  c8:	80 91 98 01 	lds	r24, 0x0198	; 0x800198 <__data_end>
  cc:	90 91 99 01 	lds	r25, 0x0199	; 0x800199 <__data_end+0x1>
  d0:	01 96       	adiw	r24, 0x01	; 1
  d2:	82 31       	cpi	r24, 0x12	; 18
  d4:	91 05       	cpc	r25, r1
  d6:	2c f4       	brge	.+10     	; 0xe2 <upOffset+0x1a>
  d8:	90 93 99 01 	sts	0x0199, r25	; 0x800199 <__data_end+0x1>
  dc:	80 93 98 01 	sts	0x0198, r24	; 0x800198 <__data_end>
  e0:	08 95       	ret
  e2:	10 92 99 01 	sts	0x0199, r1	; 0x800199 <__data_end+0x1>
  e6:	10 92 98 01 	sts	0x0198, r1	; 0x800198 <__data_end>
  ea:	08 95       	ret

000000ec <clearBoard>:
  ec:	ea e9       	ldi	r30, 0x9A	; 154
  ee:	f1 e0       	ldi	r31, 0x01	; 1
  f0:	8a ea       	ldi	r24, 0xAA	; 170
  f2:	91 e0       	ldi	r25, 0x01	; 1
  f4:	11 92       	st	Z+, r1
  f6:	11 92       	st	Z+, r1
  f8:	8e 17       	cp	r24, r30
  fa:	9f 07       	cpc	r25, r31
  fc:	d9 f7       	brne	.-10     	; 0xf4 <clearBoard+0x8>
  fe:	08 95       	ret

00000100 <initBoard>:
 100:	f5 cf       	rjmp	.-22     	; 0xec <clearBoard>
 102:	08 95       	ret

00000104 <write_board_data>:
	 }
	 write_board_data();
 }

 void write_board_data(void)
 {
 104:	0f 93       	push	r16
 106:	1f 93       	push	r17
 108:	cf 93       	push	r28
 10a:	df 93       	push	r29
	char columnValue = 0;
	for(int row = 0; row < 8; row++)
 10c:	c0 e0       	ldi	r28, 0x00	; 0
 10e:	d0 e0       	ldi	r29, 0x00	; 0
	{
		columnValue = board[row + offset] >> 1;
 110:	e0 91 98 01 	lds	r30, 0x0198	; 0x800198 <__data_end>
 114:	f0 91 99 01 	lds	r31, 0x0199	; 0x800199 <__data_end+0x1>
 118:	ec 0f       	add	r30, r28
 11a:	fd 1f       	adc	r31, r29
 11c:	ee 0f       	add	r30, r30
 11e:	ff 1f       	adc	r31, r31
 120:	e6 56       	subi	r30, 0x66	; 102
 122:	fe 4f       	sbci	r31, 0xFE	; 254
 124:	00 81       	ld	r16, Z
 126:	11 81       	ldd	r17, Z+1	; 0x01
 128:	15 95       	asr	r17
 12a:	07 95       	ror	r16
		write_data(getRowAdress(row),columnValue);
 12c:	ce 01       	movw	r24, r28
 12e:	7d d0       	rcall	.+250    	; 0x22a <getRowAdress>
 130:	60 2f       	mov	r22, r16
 132:	bb d0       	rcall	.+374    	; 0x2aa <write_data>
 }

 void write_board_data(void)
 {
	char columnValue = 0;
	for(int row = 0; row < 8; row++)
 134:	21 96       	adiw	r28, 0x01	; 1
 136:	c8 30       	cpi	r28, 0x08	; 8
 138:	d1 05       	cpc	r29, r1
 13a:	51 f7       	brne	.-44     	; 0x110 <write_board_data+0xc>
	{
		columnValue = board[row + offset] >> 1;
		write_data(getRowAdress(row),columnValue);
	}
 }
 13c:	df 91       	pop	r29
 13e:	cf 91       	pop	r28
 140:	1f 91       	pop	r17
 142:	0f 91       	pop	r16
 144:	08 95       	ret

00000146 <show_A>:
		board[row] = status;
	}		
 }

 void show_A(void)
 {
 146:	cf 93       	push	r28
 148:	df 93       	push	r29
 14a:	cd b7       	in	r28, 0x3d	; 61
 14c:	de b7       	in	r29, 0x3e	; 62
 14e:	a0 97       	sbiw	r28, 0x20	; 32
 150:	0f b6       	in	r0, 0x3f	; 63
 152:	f8 94       	cli
 154:	de bf       	out	0x3e, r29	; 62
 156:	0f be       	out	0x3f, r0	; 63
 158:	cd bf       	out	0x3d, r28	; 61
	int letterA[8] = {0,0b01111111,0b11111111,0b11001100,0b11001100,0b11001100,0b11111111,0b01111111};
 15a:	80 e1       	ldi	r24, 0x10	; 16
 15c:	e8 e0       	ldi	r30, 0x08	; 8
 15e:	f1 e0       	ldi	r31, 0x01	; 1
 160:	de 01       	movw	r26, r28
 162:	11 96       	adiw	r26, 0x01	; 1
 164:	01 90       	ld	r0, Z+
 166:	0d 92       	st	X+, r0
 168:	8a 95       	dec	r24
 16a:	e1 f7       	brne	.-8      	; 0x164 <show_A+0x1e>
	int letterB[8] = {0,0b01111111,0b11111111,0b11001100,0b11001100,0b11001100,0b11111111,0b01111111};
 16c:	80 e1       	ldi	r24, 0x10	; 16
 16e:	e8 e0       	ldi	r30, 0x08	; 8
 170:	f1 e0       	ldi	r31, 0x01	; 1
 172:	de 01       	movw	r26, r28
 174:	51 96       	adiw	r26, 0x11	; 17
 176:	01 90       	ld	r0, Z+
 178:	0d 92       	st	X+, r0
 17a:	8a 95       	dec	r24
 17c:	e1 f7       	brne	.-8      	; 0x176 <show_A+0x30>
 17e:	fe 01       	movw	r30, r28
 180:	31 96       	adiw	r30, 0x01	; 1
 182:	aa e9       	ldi	r26, 0x9A	; 154
 184:	b1 e0       	ldi	r27, 0x01	; 1
 186:	9e 01       	movw	r18, r28
 188:	2f 5e       	subi	r18, 0xEF	; 239
 18a:	3f 4f       	sbci	r19, 0xFF	; 255

	for(int row = 0; row < 8; row++)
	{
		board[row] = letterA[row];
 18c:	81 91       	ld	r24, Z+
 18e:	91 91       	ld	r25, Z+
 190:	8d 93       	st	X+, r24
 192:	9d 93       	st	X+, r25
 void show_A(void)
 {
	int letterA[8] = {0,0b01111111,0b11111111,0b11001100,0b11001100,0b11001100,0b11111111,0b01111111};
	int letterB[8] = {0,0b01111111,0b11111111,0b11001100,0b11001100,0b11001100,0b11111111,0b01111111};

	for(int row = 0; row < 8; row++)
 194:	e2 17       	cp	r30, r18
 196:	f3 07       	cpc	r31, r19
 198:	c9 f7       	brne	.-14     	; 0x18c <show_A+0x46>
	{
		board[row] = letterA[row];
	}
	
	
	board[8] = 0;
 19a:	10 92 ab 01 	sts	0x01AB, r1	; 0x8001ab <board+0x11>
 19e:	10 92 aa 01 	sts	0x01AA, r1	; 0x8001aa <board+0x10>
 1a2:	fe 01       	movw	r30, r28
 1a4:	b3 96       	adiw	r30, 0x23	; 35
 1a6:	ac ea       	ldi	r26, 0xAC	; 172
 1a8:	b1 e0       	ldi	r27, 0x01	; 1
 1aa:	9e 01       	movw	r18, r28
 1ac:	2d 5c       	subi	r18, 0xCD	; 205
 1ae:	3f 4f       	sbci	r19, 0xFF	; 255
	
	for(int row = 9; row < 17; row++)
	{
		board[row] = letterB[row];
 1b0:	81 91       	ld	r24, Z+
 1b2:	91 91       	ld	r25, Z+
 1b4:	8d 93       	st	X+, r24
 1b6:	9d 93       	st	X+, r25
	}
	
	
	board[8] = 0;
	
	for(int row = 9; row < 17; row++)
 1b8:	e2 17       	cp	r30, r18
 1ba:	f3 07       	cpc	r31, r19
 1bc:	c9 f7       	brne	.-14     	; 0x1b0 <show_A+0x6a>
	{
		board[row] = letterB[row];
	}
	
	write_board_data();
 1be:	a2 df       	rcall	.-188    	; 0x104 <write_board_data>
 }
 1c0:	a0 96       	adiw	r28, 0x20	; 32
 1c2:	0f b6       	in	r0, 0x3f	; 63
 1c4:	f8 94       	cli
 1c6:	de bf       	out	0x3e, r29	; 62
 1c8:	0f be       	out	0x3f, r0	; 63
 1ca:	cd bf       	out	0x3d, r28	; 61
 1cc:	df 91       	pop	r29
 1ce:	cf 91       	pop	r28
 1d0:	08 95       	ret

000001d2 <toggle_Lcd_E>:
 
 void display_text_int(char *str,int number)
 {
	display_text(str);
	display_int(number);
 }
 1d2:	ab 9a       	sbi	0x15, 3	; 21
 1d4:	8f ec       	ldi	r24, 0xCF	; 207
 1d6:	97 e0       	ldi	r25, 0x07	; 7
 1d8:	01 97       	sbiw	r24, 0x01	; 1
 1da:	f1 f7       	brne	.-4      	; 0x1d8 <toggle_Lcd_E+0x6>
 1dc:	00 c0       	rjmp	.+0      	; 0x1de <toggle_Lcd_E+0xc>
 1de:	00 00       	nop
 1e0:	ab 98       	cbi	0x15, 3	; 21
 1e2:	8f ec       	ldi	r24, 0xCF	; 207
 1e4:	97 e0       	ldi	r25, 0x07	; 7
 1e6:	01 97       	sbiw	r24, 0x01	; 1
 1e8:	f1 f7       	brne	.-4      	; 0x1e6 <toggle_Lcd_E+0x14>
 1ea:	00 c0       	rjmp	.+0      	; 0x1ec <toggle_Lcd_E+0x1a>
 1ec:	00 00       	nop
 1ee:	08 95       	ret

000001f0 <unable_Lcd_Rs>:
 1f0:	aa 98       	cbi	0x15, 2	; 21
 1f2:	08 95       	ret

000001f4 <lcd_command>:
 1f4:	cf 93       	push	r28
 1f6:	c8 2f       	mov	r28, r24
 1f8:	85 bb       	out	0x15, r24	; 21
 1fa:	fa df       	rcall	.-12     	; 0x1f0 <unable_Lcd_Rs>
 1fc:	ea df       	rcall	.-44     	; 0x1d2 <toggle_Lcd_E>
 1fe:	c2 95       	swap	r28
 200:	c0 7f       	andi	r28, 0xF0	; 240
 202:	c5 bb       	out	0x15, r28	; 21
 204:	f5 df       	rcall	.-22     	; 0x1f0 <unable_Lcd_Rs>
 206:	e5 df       	rcall	.-54     	; 0x1d2 <toggle_Lcd_E>
 208:	cf 91       	pop	r28
 20a:	08 95       	ret

0000020c <display_clear>:

 void display_clear()
 {
	lcd_command(0x01);	//clear display
 20c:	81 e0       	ldi	r24, 0x01	; 1
 20e:	f2 cf       	rjmp	.-28     	; 0x1f4 <lcd_command>
 210:	08 95       	ret

00000212 <init_Lcd_4_bit_mode>:
	toggle_Lcd_E();		
 }

  void init_Lcd_4_bit_mode(void)
  {
	  DDRC = 0b11111111;	//PORTC (7:0) output
 212:	8f ef       	ldi	r24, 0xFF	; 255
 214:	84 bb       	out	0x14, r24	; 20
	  PORTC = 0x00;		//Maak alle pins van portc laag, ook e en rs
 216:	15 ba       	out	0x15, r1	; 21

	  //PORTC = 0x28;		//Function set (4-bit interface, 2 lines, 5*8 Pixels)
	  PORTC = 0x20;		//Function set (4-bit interface, 1 lines, 5*8 Pixels)
 218:	80 e2       	ldi	r24, 0x20	; 32
 21a:	85 bb       	out	0x15, r24	; 21
	  toggle_Lcd_E();
 21c:	da df       	rcall	.-76     	; 0x1d2 <toggle_Lcd_E>
	  
	  //lcd_command(0x0E);	//Zet display aan en cursor aan en maak cursor niet knipperent	(0x0E -> 0b00001110)
	  lcd_command(0x0C);	//Zet display aan en cursor uit en maak cursor niet knipperent		(0x0F -> 0b00001100)
 21e:	8c e0       	ldi	r24, 0x0C	; 12
 220:	e9 df       	rcall	.-46     	; 0x1f4 <lcd_command>
	  lcd_command(0x06);	//Entry mode 06, van links naar rechts schrijven. cursor schuift mee
 222:	86 e0       	ldi	r24, 0x06	; 6
 224:	e7 df       	rcall	.-50     	; 0x1f4 <lcd_command>
	  display_clear();
 226:	f2 cf       	rjmp	.-28     	; 0x20c <display_clear>
 228:	08 95       	ret

0000022a <getRowAdress>:
 22a:	80 50       	subi	r24, 0x00	; 0
outputs:
notes:
Version :    	DMK, Initial code
*******************************************************************/
{
	TWCR = (0x80 | 0x10 | 0x04);
 22c:	9f 4f       	sbci	r25, 0xFF	; 255
 22e:	fc 01       	movw	r30, r24
 230:	80 81       	ld	r24, Z
 232:	08 95       	ret

00000234 <twi_start>:
 234:	84 ea       	ldi	r24, 0xA4	; 164
 236:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
 23a:	e4 e7       	ldi	r30, 0x74	; 116
 23c:	f0 e0       	ldi	r31, 0x00	; 0
 23e:	80 81       	ld	r24, Z
 240:	88 23       	and	r24, r24
 242:	ec f7       	brge	.-6      	; 0x23e <twi_start+0xa>
 244:	08 95       	ret

00000246 <twi_tx>:
outputs:
notes:
Version :    	DMK, Initial code
*******************************************************************/
{
	TWDR = data;
 246:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <__TEXT_REGION_LENGTH__+0x7e0073>
	TWCR = (0x80 | 0x04);
 24a:	84 e8       	ldi	r24, 0x84	; 132
 24c:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
	while( 0 == (TWCR & 0x80) );
 250:	e4 e7       	ldi	r30, 0x74	; 116
 252:	f0 e0       	ldi	r31, 0x00	; 0
 254:	80 81       	ld	r24, Z
 256:	88 23       	and	r24, r24
 258:	ec f7       	brge	.-6      	; 0x254 <twi_tx+0xe>
}
 25a:	08 95       	ret

0000025c <twi_init>:
inputs:
outputs:
notes:			TWI clock is set to 100 kHz
Version :    	DMK, Initial code
*******************************************************************/
{
 25c:	1f 93       	push	r17
 25e:	cf 93       	push	r28
 260:	df 93       	push	r29
	TWSR = 0;
 262:	10 92 71 00 	sts	0x0071, r1	; 0x800071 <__TEXT_REGION_LENGTH__+0x7e0071>
	TWBR = 32;	 // TWI clock set to 100kHz, prescaler = 0
 266:	80 e2       	ldi	r24, 0x20	; 32
 268:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <__TEXT_REGION_LENGTH__+0x7e0070>
	// Init HT16K22. Page 32 datasheet
	twi_start();
 26c:	e3 df       	rcall	.-58     	; 0x234 <twi_start>
	twi_tx(0xE0);	// Display I2C addres + R/W bit
 26e:	80 ee       	ldi	r24, 0xE0	; 224
 270:	ea df       	rcall	.-44     	; 0x246 <twi_tx>
	twi_tx(0x21);	// Internal osc on (page 10 HT16K33)
 272:	81 e2       	ldi	r24, 0x21	; 33
 274:	e8 df       	rcall	.-48     	; 0x246 <twi_tx>
 276:	c4 e7       	ldi	r28, 0x74	; 116
outputs:
notes:
Version :    	DMK, Initial code
*******************************************************************/
{
	TWCR = (0x80 | 0x10 | 0x04);
 278:	d0 e0       	ldi	r29, 0x00	; 0
 27a:	14 e9       	ldi	r17, 0x94	; 148
 27c:	18 83       	st	Y, r17
	twi_start();
	twi_tx(0xE0);	// Display I2C addres + R/W bit
	twi_tx(0x21);	// Internal osc on (page 10 HT16K33)
	twi_stop();
	
	twi_start();
 27e:	da df       	rcall	.-76     	; 0x234 <twi_start>
	twi_tx(0xE0);	// Display I2C address + R/W bit
 280:	80 ee       	ldi	r24, 0xE0	; 224
 282:	e1 df       	rcall	.-62     	; 0x246 <twi_tx>
	twi_tx(0xA0);	// HT16K33 pins all output
 284:	80 ea       	ldi	r24, 0xA0	; 160
 286:	df df       	rcall	.-66     	; 0x246 <twi_tx>
outputs:
notes:
Version :    	DMK, Initial code
*******************************************************************/
{
	TWCR = (0x80 | 0x10 | 0x04);
 288:	18 83       	st	Y, r17
	twi_start();
	twi_tx(0xE0);	// Display I2C address + R/W bit
	twi_tx(0xA0);	// HT16K33 pins all output
	twi_stop();
	
	twi_start();
 28a:	d4 df       	rcall	.-88     	; 0x234 <twi_start>
	twi_tx(0xE0);	// Display I2C address + R/W bit
 28c:	80 ee       	ldi	r24, 0xE0	; 224
 28e:	db df       	rcall	.-74     	; 0x246 <twi_tx>
	twi_tx(0xE3);	// Display Dimming 4/16 duty cycle
 290:	83 ee       	ldi	r24, 0xE3	; 227
 292:	d9 df       	rcall	.-78     	; 0x246 <twi_tx>
 294:	18 83       	st	Y, r17
outputs:
notes:
Version :    	DMK, Initial code
*******************************************************************/
{
	TWCR = (0x80 | 0x10 | 0x04);
 296:	ce df       	rcall	.-100    	; 0x234 <twi_start>
	twi_start();
	twi_tx(0xE0);	// Display I2C address + R/W bit
	twi_tx(0xE3);	// Display Dimming 4/16 duty cycle
	twi_stop();
	
	twi_start();
 298:	80 ee       	ldi	r24, 0xE0	; 224
 29a:	d5 df       	rcall	.-86     	; 0x246 <twi_tx>
	twi_tx(0xE0);	// Display I2C address + R/W bit
 29c:	81 e8       	ldi	r24, 0x81	; 129
 29e:	d3 df       	rcall	.-90     	; 0x246 <twi_tx>
 2a0:	18 83       	st	Y, r17
	twi_tx(0x81);	// Display OFF - Blink On
 2a2:	df 91       	pop	r29
 2a4:	cf 91       	pop	r28
 2a6:	1f 91       	pop	r17
outputs:
notes:
Version :    	DMK, Initial code
*******************************************************************/
{
	TWCR = (0x80 | 0x10 | 0x04);
 2a8:	08 95       	ret

000002aa <write_data>:
	twi_start();
	twi_tx(0xE0);	// Display I2C address + R/W bit
	twi_tx(0x81);	// Display OFF - Blink On
	twi_stop();
	
}
 2aa:	cf 93       	push	r28
 2ac:	df 93       	push	r29
 2ae:	d8 2f       	mov	r29, r24
 2b0:	c6 2f       	mov	r28, r22
	while( 0 == (TWCR & 0x80) );
}

void write_data(unsigned char adress,unsigned char data)
{
	twi_start();
 2b2:	c0 df       	rcall	.-128    	; 0x234 <twi_start>
	twi_tx(0xE0);	// Display I2C addres + R/W bit
 2b4:	80 ee       	ldi	r24, 0xE0	; 224
 2b6:	c7 df       	rcall	.-114    	; 0x246 <twi_tx>
	twi_tx(adress);	// Address
 2b8:	8d 2f       	mov	r24, r29
 2ba:	c5 df       	rcall	.-118    	; 0x246 <twi_tx>
	twi_tx(data);	// data
 2bc:	8c 2f       	mov	r24, r28
 2be:	c3 df       	rcall	.-122    	; 0x246 <twi_tx>
 2c0:	84 e9       	ldi	r24, 0x94	; 148
outputs:
notes:
Version :    	DMK, Initial code
*******************************************************************/
{
	TWCR = (0x80 | 0x10 | 0x04);
 2c2:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x7e0074>
 2c6:	df 91       	pop	r29
	twi_start();
	twi_tx(0xE0);	// Display I2C addres + R/W bit
	twi_tx(adress);	// Address
	twi_tx(data);	// data
	twi_stop();
}
 2c8:	cf 91       	pop	r28
 2ca:	08 95       	ret

000002cc <wait>:
 2cc:	18 16       	cp	r1, r24
				clock value is set. This is used by _delay_ms inside
				util/delay.h
Version :    	DMK, Initial code
*******************************************************************/
{
	for (int i=0; i<ms; i++)
 2ce:	19 06       	cpc	r1, r25
 2d0:	6c f4       	brge	.+26     	; 0x2ec <wait+0x20>
 2d2:	20 e0       	ldi	r18, 0x00	; 0
 2d4:	30 e0       	ldi	r19, 0x00	; 0
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 2d6:	ef ec       	ldi	r30, 0xCF	; 207
 2d8:	f7 e0       	ldi	r31, 0x07	; 7
 2da:	31 97       	sbiw	r30, 0x01	; 1
 2dc:	f1 f7       	brne	.-4      	; 0x2da <wait+0xe>
 2de:	00 c0       	rjmp	.+0      	; 0x2e0 <wait+0x14>
 2e0:	00 00       	nop
 2e2:	2f 5f       	subi	r18, 0xFF	; 255
 2e4:	3f 4f       	sbci	r19, 0xFF	; 255
 2e6:	82 17       	cp	r24, r18
 2e8:	93 07       	cpc	r25, r19
 2ea:	a9 f7       	brne	.-22     	; 0x2d6 <wait+0xa>
 2ec:	08 95       	ret

000002ee <initMatrix>:
		wait(1000);
    }
}

void initMatrix(){
	twi_init();
 2ee:	b6 df       	rcall	.-148    	; 0x25c <twi_init>
	initBoard();
 2f0:	07 df       	rcall	.-498    	; 0x100 <initBoard>
	init_Lcd_4_bit_mode();
 2f2:	8f df       	rcall	.-226    	; 0x212 <init_Lcd_4_bit_mode>
 2f4:	8f ef       	ldi	r24, 0xFF	; 255
	
	DDRA = 0b11111111;
 2f6:	8a bb       	out	0x1a, r24	; 26
 2f8:	8a b7       	in	r24, 0x3a	; 58

	EICRB |= 0b11000000; //set INT7 faling edge
 2fa:	80 6c       	ori	r24, 0xC0	; 192
 2fc:	8a bf       	out	0x3a, r24	; 58
 2fe:	89 b7       	in	r24, 0x39	; 57
	EIMSK |= 0b10000000; //enable INT&
 300:	80 68       	ori	r24, 0x80	; 128
 302:	89 bf       	out	0x39, r24	; 57
 304:	78 94       	sei
	//enable global interrupt system
	sei();
 306:	08 95       	ret

00000308 <main>:
 308:	f2 df       	rcall	.-28     	; 0x2ee <initMatrix>
}

int main(void)
{
	initMatrix();
	wait(500);
 30a:	84 ef       	ldi	r24, 0xF4	; 244
 30c:	91 e0       	ldi	r25, 0x01	; 1
	
    /* Replace with your application code */
    while (1) 
    {
		clearBoard();
 30e:	de df       	rcall	.-68     	; 0x2cc <wait>
		show_A();
 310:	ed de       	rcall	.-550    	; 0xec <clearBoard>
 312:	19 df       	rcall	.-462    	; 0x146 <show_A>
		write_board_data();
 314:	f7 de       	rcall	.-530    	; 0x104 <write_board_data>
		upOffset();
 316:	d8 de       	rcall	.-592    	; 0xc8 <upOffset>
 318:	88 ee       	ldi	r24, 0xE8	; 232
		wait(1000);
 31a:	93 e0       	ldi	r25, 0x03	; 3
 31c:	d7 df       	rcall	.-82     	; 0x2cc <wait>
 31e:	f8 cf       	rjmp	.-16     	; 0x310 <main+0x8>

00000320 <_exit>:
 320:	f8 94       	cli

00000322 <__stop_program>:
 322:	ff cf       	rjmp	.-2      	; 0x322 <__stop_program>
